/**
 * Module de gestion de la connexion WebSocket
 */
import { EVENTS, emitEvent } from './utils.js';
import { translate } from './i18n.js';

// Configuration WebSocket
const WS_URLS = {
  LOCAL: 'ws://guillaume.local:3000',
  PROD: 'wss://your-production-websocket-server.com' // √Ä remplacer par l'URL WebSocket de production
};

// D√©terminer l'URL WebSocket en fonction de l'environnement
const getWebSocketUrl = () => {
  // Si nous sommes sur GitHub Pages (ou en production)
  if (window.location.hostname.includes('github.io') || window.location.hostname === 'localhost') {
    return WS_URLS.PROD;
  }
  // Sinon, utiliser l'URL locale
  return WS_URLS.LOCAL;
};

const DEFAULT_WS_URL = getWebSocketUrl();
const RECONNECT_INTERVAL = 5000; // 5 secondes
const MAX_RECONNECT_ATTEMPTS = 10;

// √âtats de connexion
const CONNECTION_STATES = {
  CONNECTED: 'connected',
  CONNECTING: 'connecting',
  DISCONNECTED: 'disconnected'
};

// √âtat actuel
let socket = null;
let reconnectAttempts = 0;
let reconnectTimeout = null;
let connectionState = CONNECTION_STATES.DISCONNECTED;

/**
 * Met √† jour l'√©tat de connexion dans l'UI
 * @param {string} state - √âtat de connexion
 */
const updateConnectionStatus = (state) => {
  connectionState = state;
  
  // Mettre √† jour l'indicateur de statut dans l'UI
  const statusElement = document.querySelector('.connection-status');
  if (statusElement) {
    statusElement.setAttribute('data-status', state);
    
    // Mettre √† jour l'ic√¥ne selon l'√©tat
    const iconElement = statusElement.querySelector('.status-icon');
    if (iconElement) {
      switch (state) {
        case CONNECTION_STATES.CONNECTED:
          iconElement.textContent = 'üü¢';
          break;
        case CONNECTION_STATES.CONNECTING:
          iconElement.textContent = 'üü†';
          break;
        case CONNECTION_STATES.DISCONNECTED:
          iconElement.textContent = 'üî¥';
          break;
      }
    }
    
    // Mettre √† jour le texte selon l'√©tat
    const textElement = statusElement.querySelector('.status-text');
    if (textElement) {
      const key = `connection.${state}`;
      textElement.setAttribute('data-i18n', key);
      textElement.textContent = translate(key);
    }
  }
  
  // √âmettre un √©v√©nement pour informer les autres modules
  emitEvent(EVENTS.CONNECTION_STATUS_CHANGED, state);
};

/**
 * G√®re les messages re√ßus du WebSocket
 * @param {MessageEvent} event - √âv√©nement de message WebSocket
 */
const handleMessage = (event) => {
  console.log('[WebSocket] ====== D√âBUT TRAITEMENT MESSAGE ======');
  console.log('[WebSocket] Message brut re√ßu:', event.data);
  
  try {
    console.log('[WebSocket] Message re√ßu (d√©but):', event.data.substring(0, 100) + (event.data.length > 100 ? '...' : ''));
    console.log('[WebSocket] Taille du message:', event.data.length, 'caract√®res');
    
    const data = JSON.parse(event.data);
    console.log('[WebSocket] Structure du message:', Object.keys(data).join(', '));
    console.log('[WebSocket] Type de message:', data.type || 'non sp√©cifi√©');
    
    // Format d√©tect√© automatiquement
    console.log('[WebSocket] Structure du message re√ßu:', JSON.stringify(Object.keys(data)));
    
    // Traiter le message selon son format
    if (data.type === 'menuUpdate' && data.menu) {
      // Format 1: {type: 'menuUpdate', menu: [...]}
      console.log('[WebSocket] Format d√©tect√©: type=menuUpdate');
      console.log('[WebSocket] Menu re√ßu:', data.menu ? `${data.menu.length} plats` : 'Menu vide ou invalide');
      if (data.menu && data.menu.length > 0) {
        console.log('[WebSocket] Premier plat complet:', JSON.stringify(data.menu[0], null, 2));
        if (data.menu[0].ingredients) {
          console.log('[WebSocket] Ingr√©dients du premier plat:', JSON.stringify(data.menu[0].ingredients, null, 2));
        }
      }
      
      console.log(`[WebSocket] √âmission de l'√©v√©nement ${EVENTS.MENU_UPDATED} avec ${data.menu?.length || 0} plats`);
      emitEvent(EVENTS.MENU_UPDATED, data.menu);
    } 
    else if (data.menu && Array.isArray(data.menu)) {
      // Format 2: {menu: [...]}
      console.log('[WebSocket] Format d√©tect√©: {menu: [...]}');
      console.log('[WebSocket] Menu re√ßu:', `${data.menu.length} plats`);
      if (data.menu.length > 0) {
        console.log('[WebSocket] Premier plat complet:', JSON.stringify(data.menu[0], null, 2));
        if (data.menu[0].ingredients) {
          console.log('[WebSocket] Ingr√©dients du premier plat:', JSON.stringify(data.menu[0].ingredients, null, 2));
        }
      }
      
      console.log(`[WebSocket] √âmission de l'√©v√©nement ${EVENTS.MENU_UPDATED} avec ${data.menu.length} plats`);
      emitEvent(EVENTS.MENU_UPDATED, data.menu);
    }
    else if (data.type === 'menuUpdate' && data.payload) {
      // Format 3: {type: 'menuUpdate', payload: [...]}
      console.log('[WebSocket] Format d√©tect√©: type=menuUpdate avec payload');
      console.log('[WebSocket] Menu re√ßu via payload:', data.payload ? `${data.payload.length} plats` : 'Payload vide ou invalide');
      if (data.payload && data.payload.length > 0) {
        console.log('[WebSocket] Premier plat complet via payload:', JSON.stringify(data.payload[0], null, 2));
        if (data.payload[0].ingredients) {
          console.log('[WebSocket] Ingr√©dients du premier plat via payload:', JSON.stringify(data.payload[0].ingredients, null, 2));
        }
      }
      
      console.log(`[WebSocket] √âmission de l'√©v√©nement ${EVENTS.MENU_UPDATED} avec ${data.payload?.length || 0} plats`);
      emitEvent(EVENTS.MENU_UPDATED, data.payload);
    }
    else if (data.ingredients && Array.isArray(data.ingredients)) {
      // Format: {ingredients: [...]}
      console.log('[WebSocket] Format d√©tect√©: {ingredients: [...]}');
      console.log('[WebSocket] Ingr√©dients re√ßus:', `${data.ingredients.length} ingr√©dients`);
      console.log('[WebSocket] Ingr√©dients complets:', JSON.stringify(data.ingredients, null, 2));
      
      console.log(`[WebSocket] √âmission de l'√©v√©nement ${EVENTS.INGREDIENTS_UPDATED} avec ${data.ingredients.length} ingr√©dients`);
      emitEvent(EVENTS.INGREDIENTS_UPDATED, data.ingredients);
    }
    else if (data.type === 'qr_codes_response' && data.qrCodes && typeof data.qrCodes === 'object') {
      // Format: {type: 'qr_codes_response', qrCodes: {salle: {...}, menu: {...}}}
      console.log('[WebSocket] Format d√©tect√©: qr_codes_response');
      console.log('[WebSocket] QR codes re√ßus:', Object.keys(data.qrCodes));
      console.log('[WebSocket] QR codes complets:', JSON.stringify(data.qrCodes, null, 2));
      
      console.log(`[WebSocket] √âmission de l'√©v√©nement ${EVENTS.QR_CODES_UPDATED} avec les QR codes`);
      emitEvent(EVENTS.QR_CODES_UPDATED, data.qrCodes);
    }
    else {
      // Message non reconnu
      console.log('[WebSocket] Message non reconnu comme menu ou ingr√©dients:', JSON.stringify(data, null, 2));
    }
    
    console.log('[WebSocket] ====== FIN TRAITEMENT MESSAGE ======');
  } catch (error) {
    console.error('[WebSocket] Erreur de traitement du message:', error);
    console.error('[WebSocket] Message d\'erreur:', error.message);
    console.error('[WebSocket] Stack trace:', error.stack);
    console.error('[WebSocket] Donn√©es re√ßues (d√©but):', 
      event.data ? event.data.substring(0, 200) + (event.data.length > 200 ? '...' : '') : 'Aucune donn√©e');
    console.error('[WebSocket] ====== FIN AVEC ERREUR ======');
  }
};

/**
 * Tente de se reconnecter au serveur WebSocket
 */
const attemptReconnect = () => {
  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
    console.error('Nombre maximum de tentatives de reconnexion atteint.');
    updateConnectionStatus(CONNECTION_STATES.DISCONNECTED);
    return;
  }
  
  reconnectAttempts++;
  updateConnectionStatus(CONNECTION_STATES.CONNECTING);
  console.log(`Tentative de reconnexion (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
  
  // Tenter de cr√©er une nouvelle connexion
  connectToWebSocket();
};

/**
 * Se connecte au serveur WebSocket
 */
export const connectToWebSocket = (url = DEFAULT_WS_URL) => {
  // Nettoyer toute connexion existante
  if (socket) {
    socket.close();
  }
  
  // Nettoyer tout timeout de reconnexion
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
    reconnectTimeout = null;
  }
  
  try {
    updateConnectionStatus(CONNECTION_STATES.CONNECTING);
    
    // Cr√©er une nouvelle connexion WebSocket
    socket = new WebSocket(url);
    
    // √âv√©nement d'ouverture de connexion
    socket.addEventListener('open', () => {
      console.log('[WebSocket] Connexion WebSocket √©tablie');
      reconnectAttempts = 0;
      updateConnectionStatus(CONNECTION_STATES.CONNECTED);
      
      // Envoyer une demande de menu au serveur
      try {
        console.log('[WebSocket] Envoi d\'une demande de menu');
        
        // Format 1: { type: 'requestMenu' }
        console.log('[WebSocket] Essai format 1: { type: "requestMenu" }');
        socket.send(JSON.stringify({ type: 'requestMenu' }));
        
        // Attendre un peu et envoyer une deuxi√®me demande dans un autre format si n√©cessaire
        setTimeout(() => {
          // Format 2: { action: 'getMenu' }
          console.log('[WebSocket] Essai format 2: { action: "getMenu" }');
          socket.send(JSON.stringify({ action: 'getMenu', timestamp: Date.now() }));
        }, 1000);
        
      } catch (error) {
        console.error('[WebSocket] Erreur lors de l\'envoi de la demande:', error);
      }
      
      // Ajouter un log apr√®s quelques secondes pour v√©rifier si des messages ont √©t√© re√ßus
      setTimeout(() => {
        if (connectionState === CONNECTION_STATES.CONNECTED) {
          console.log('[WebSocket] √âtat apr√®s 5 secondes de connexion:');
          console.log('[WebSocket] - √âtat de connexion:', connectionState);
          console.log('[WebSocket] - Socket readyState:', socket ? socket.readyState : 'Socket non d√©fini');
          console.log('[WebSocket] - Si aucun message n\'a √©t√© re√ßu, v√©rifiez que le serveur:');
          console.log('[WebSocket] - 1. Accepte bien les connexions √† l\'URL', DEFAULT_WS_URL);
          console.log('[WebSocket] - 2. Envoie des messages de type "menuUpdate" avec une propri√©t√© "menu"');
          console.log('[WebSocket] - 3. R√©pond bien aux messages de type "requestMenu"');
        }
      }, 5000);
    });
    
    // √âv√©nement de message
    socket.addEventListener('message', handleMessage);
    
    // √âv√©nement d'erreur
    socket.addEventListener('error', (error) => {
      console.error('[WebSocket] ====== ERREUR DE CONNEXION ======');
      console.error('[WebSocket] Erreur WebSocket:', error);
      console.error('[WebSocket] URL de connexion:', url);
      console.error('[WebSocket] √âtat actuel:', connectionState);
      console.error('[WebSocket] readyState:', socket ? socket.readyState : 'Socket non d√©fini');
      console.error('[WebSocket] V√©rifiez que le serveur est bien en cours d\'ex√©cution √† cette adresse');
      console.error('[WebSocket] ====== FIN ERREUR DE CONNEXION ======');
    });
    
    // √âv√©nement de fermeture
    socket.addEventListener('close', (event) => {
      console.log('[WebSocket] ====== FERMETURE DE CONNEXION ======');
      console.log(`[WebSocket] Connexion WebSocket ferm√©e. Code: ${event.code}, Raison: ${event.reason || 'Non sp√©cifi√©e'}`);
      
      // Informations sur les codes d'erreur communs
      if (event.code === 1000) {
        console.log('[WebSocket] Fermeture normale de la connexion');
      } else if (event.code === 1001) {
        console.log('[WebSocket] Le point de terminaison est "en train de partir" (navigateur ferm√©, etc.)');
      } else if (event.code === 1002) {
        console.log('[WebSocket] Erreur de protocole');
      } else if (event.code === 1003) {
        console.log('[WebSocket] Type de donn√©es non accept√©');
      } else if (event.code === 1005) {
        console.log('[WebSocket] Aucun code d\'√©tat re√ßu');
      } else if (event.code === 1006) {
        console.log('[WebSocket] Connexion ferm√©e anormalement - V√©rifiez que le serveur WebSocket est en cours d\'ex√©cution');
      } else if (event.code === 1007) {
        console.log('[WebSocket] Message invalide (non-UTF8)');
      } else if (event.code === 1008) {
        console.log('[WebSocket] Violation de politique');
      } else if (event.code === 1009) {
        console.log('[WebSocket] Message trop grand');
      } else if (event.code === 1011) {
        console.log('[WebSocket] Erreur interne du serveur');
      } else if (event.code === 1015) {
        console.log('[WebSocket] √âchec TLS');
      }
      
      updateConnectionStatus(CONNECTION_STATES.DISCONNECTED);
      console.log(`[WebSocket] Reconnexion pr√©vue dans ${RECONNECT_INTERVAL/1000} secondes`);
      console.log('[WebSocket] ====== FIN FERMETURE DE CONNEXION ======');
      
      // Tenter de se reconnecter automatiquement
      reconnectTimeout = setTimeout(attemptReconnect, RECONNECT_INTERVAL);
    });
  } catch (error) {
    console.error('Erreur lors de la cr√©ation de la connexion WebSocket:', error);
    updateConnectionStatus(CONNECTION_STATES.DISCONNECTED);
    
    // Tenter de se reconnecter
    reconnectTimeout = setTimeout(attemptReconnect, RECONNECT_INTERVAL);
  }
};

/**
 * Demande les ingr√©dients au serveur WebSocket
 */
export const requestIngredients = () => {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    console.error('[WebSocket] Impossible de demander les ingr√©dients: WebSocket non connect√©');
    return false;
  }
  
  try {
    const message = {
      action: 'getIngredients',
      timestamp: Date.now()
    };
    socket.send(JSON.stringify(message));
    console.log('[WebSocket] Demande d\'ingr√©dients envoy√©e');
    return true;
  } catch (error) {
    console.error('[WebSocket] Erreur lors de l\'envoi de la demande d\'ingr√©dients:', error);
    return false;
  }
};

/**
 * Demande les QR codes au serveur WebSocket
 */
export const requestQRCodes = () => {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    console.error('[WebSocket] Impossible de demander les QR codes: WebSocket non connect√©');
    return false;
  }
  
  try {
    const message = {
      type: 'get_qr_codes',
      action: 'getQRCodes'
    };
    socket.send(JSON.stringify(message));
    console.log('[WebSocket] Demande de QR codes envoy√©e:', message);
    return true;
  } catch (error) {
    console.error('[WebSocket] Erreur lors de l\'envoi de la demande de QR codes:', error);
    return false;
  }
};

/**
 * Initialise le module WebSocket
 */
export const initWebSocket = (url = DEFAULT_WS_URL) => {
  console.log('[WebSocket] Initialisation du module WebSocket');
  console.log(`[WebSocket] Adresse du serveur: ${url}`);
  
  // D√©marrer avec l'√©tat d√©connect√©
  updateConnectionStatus(CONNECTION_STATES.DISCONNECTED);
  
  // √âtablir la connexion initiale
  console.log('[WebSocket] Tentative de connexion initiale...');
  connectToWebSocket(url);
  
  // G√©rer la reconnexion automatique lorsque la page devient visible
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && connectionState === CONNECTION_STATES.DISCONNECTED) {
      connectToWebSocket(url);
    }
  });
};

export default {
  initWebSocket,
  connectToWebSocket,
  requestIngredients,
  requestQRCodes
};
